{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"TuffSeal","text":"<p>A small, explicit and embeddable scripting language with a C-style syntax, implemented entirely in Luau</p>"},{"location":"#example","title":"Example","text":"<pre><code>let x = 10;\nprint(x * 2) // semicolons are optional!\n</code></pre>"},{"location":"#why-tuffseal","title":"Why TuffSeal?","text":"<ul> <li>Easy to embed</li> <li>Explicit semantics</li> <li>Designed for learning and experimentation</li> </ul>"},{"location":"#key-characteristics","title":"Key Characteristics","text":"<ul> <li>Interpreted, AST-based execution</li> <li>Dynamically typed</li> <li>First-class arrays and dictionaries</li> <li>Expression-based functions</li> <li>Built-in package manager (PMS / PackMySeal)</li> </ul>"},{"location":"#status","title":"Status","text":"<p>TuffSeal is under active development. Syntax and semantics may evolve.</p>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#installation","title":"Installation","text":""},{"location":"getting-started/#tuffseal","title":"TuffSeal","text":"<p>Download the latest TuffSeal release from github: - https://github.com/TuffSeal/TuffSeal/releases</p> <p>Extract the binary and add it to your <code>PATH</code>.</p> <p>Verify installation:</p> <pre><code>tuffseal --version\n</code></pre> <p>Once TuffSeal is installed, you can run test code by running it from a <code>.tfs</code> file or from the REPL.</p> <p>To launch the repl:</p> <pre><code>tuffseal --repl\n</code></pre> <p>Inside the repl you can directly execute code. For example:</p> <pre><code>print(\"Hello, world!\");\n</code></pre> <p>To run TuffSeal code contained in a <code>.tfs</code> script:</p> <pre><code>tuffseal --run script_path.tfs\n</code></pre>"},{"location":"getting-started/#packmyseal-pms","title":"PackMySeal (PMS)","text":"<p>PMS is the official package manager for TuffSeal.</p>"},{"location":"getting-started/#windows-x86_64","title":"Windows (x86_64)","text":"<p>Currently, precompiled binaries are only provided for Windows(x86_64). Download it from the TuffSeal releases page and add it to your <code>PATH</code>.</p> <p>Verify:</p> <pre><code>pms --version\n</code></pre>"},{"location":"getting-started/#other-platforms","title":"Other Platforms","text":"<p>On Linux, macOS or non-x86_64 systems. PMS must be built locally:</p> <pre><code>./build_pms.sh\n</code></pre> <p>or on Windows:</p> <pre><code>build_pms.bat\n</code></pre> <p>NOTE: Python is required to build TuffSeal. PyInstaller and other dependencies will be installed automatically by the build script.</p>"},{"location":"getting-started/#first-project-with-pms","title":"First Project with PMS","text":""},{"location":"getting-started/#creating-a-project","title":"Creating a Project","text":"<p>To initialize a new project, run the following commands:</p> <pre><code>pms init my-project\ncd my-project\n</code></pre> <p>PMS will create a new folder called \"my-project\". Inside of the folder, you will see a file: <code>main.tfs</code> This is the main script inside your project.</p> <p>To run your project, run:</p> <pre><code>tuffseal run main.tfs\n</code></pre>"},{"location":"guide/attributes/","title":"Attribute Helpers","text":"<pre><code>let obj = {\n    a: 5,\n    b: 10\n}\n\nif (hasattr(obj, \"a\")) {\n    let v = getattr(obj, \"a\");\n    print(v); // 5\n}\n</code></pre> <p>These helpers allow explicit attribute inspection and access.</p>"},{"location":"guide/attributes/#hasattr","title":"<code>hasattr</code>","text":"<pre><code>let obj = {\n    x: 10,\n    y: 41\n}\n\nif (hasattr(obj, \"x\")) {\n    print(\"attribute exists!\");\n}\n</code></pre> <p><code>hasattr</code> checks if a dictionary contains a specificed key. If it does, it returns <code>true</code>, if not then it returns <code>false</code>.</p>"},{"location":"guide/attributes/#getattr","title":"<code>getattr</code>","text":"<pre><code>let obj = {\n    x: 10,\n    y: 41\n}\n\nif (hasattr(obj, \"x\")) {\n    print(getattr(obj, \"x\"));\n}\n</code></pre> <p><code>getattr</code> returns the value inside of a dictionary associated with a specified key. If the value or key does not exist, it returns <code>null</code>.</p>"},{"location":"guide/attributes/#setattr","title":"<code>setattr</code>","text":"<pre><code>let obj = {\n    x: 10\n}\n\nsetattr(obj, \"y\", 41);\nprint(obj.y); // 41;\nprint(getattr(\"obj\", \"y\")); // 41\n</code></pre> <p><code>setattr</code> adds a new key to the dictionary and assigns a provided value to it.</p>"},{"location":"guide/comments/","title":"Comments","text":"<p>TuffSeal currently only support single-line comments</p> <pre><code>// This is a comment\n</code></pre> <p>Comments are ignored by the lexer.</p> <p>Block comments will be added in a future update.</p>"},{"location":"guide/control-flow/","title":"Control Flow","text":""},{"location":"guide/control-flow/#conditionals","title":"Conditionals","text":"<pre><code>const x = 5;\n\nif (x == 5) {\n    print(\"x is 5!\");\n} elseif (x == 10) {\n    print(\"x is 10!\");\n} else {\n    print(\"x is something else!\");\n}\n</code></pre>"},{"location":"guide/control-flow/#numeric-for-loop","title":"Numeric For Loop","text":"<pre><code>// for (i = starting point, max value of i (value to stop at), increment(how much to increase i by every time))\nfor (i = 1, 5, 1) {\n    print(i); // 1, 2, 3, 4, 5\n}\n</code></pre>"},{"location":"guide/control-flow/#dictionary-iteration","title":"Dictionary Iteration","text":"<pre><code>const dict = {\n    a: 5,\n    b: 10\n};\n\nfor (key, value in dict) {\n    print(key, value);\n}\n</code></pre>"},{"location":"guide/control-flow/#array-iteration","title":"Array Iteration","text":"<pre><code>const arr = [1, 2, 3];\n\nconst _ip = ipairs(arr);\nfor (index, value in _ip)\n{\n    print(index, value);\n}\n</code></pre>"},{"location":"guide/control-flow/#while-loop","title":"While Loop","text":"<pre><code>while (condition) {\n    // ...\n}\n\n// example:\nwhile (true) {\n    // loop forever\n}\n\nlet a = 1;\nwhile (a &lt;= 5)\n{\n    a = a + 1;\n    print(a);\n}\n</code></pre>"},{"location":"guide/functions/","title":"Functions","text":"<p>Functions are declared using <code>fn</code>. Functions can be <code>let</code> or <code>const</code>.</p> <pre><code>let fn add(a, b)\n{\n    a + b;\n}\n\nconst fn sub(a, b)\n{\n    // const functions cannot be reassigned / hooked\n    a - b;\n}\n\nfn mult(a, b)\n{\n    a * b;\n}\n</code></pre> <p>If a function declare type(<code>let</code>/<code>const</code>) is not defined, it defaults to <code>let</code>.</p> <p>NOTE: TuffSeal doesn't have <code>return</code>. The last expression is returned automatically.</p>"},{"location":"guide/methods/","title":"Methods &amp; Self Calls","text":"<p>TuffSeal supports method-style calls using <code>!</code>.</p> <pre><code>fn setA(self) {\n    setattr(self, \"a\", 5);\n}\n\nlet obj = {\n    a: 1,\n    setA: setA\n};\n\nprint(obj.a); // 1\n\nobj.setA()!;\n\nprint(obj.a); // 5\n</code></pre> <p>The <code>!</code> operator explictly passes <code>self</code>.</p>"},{"location":"guide/modules/","title":"Modules &amp; Imports","text":"<p>Modules can be:</p> <ul> <li><code>.tfs</code> files</li> <li>Folders containing <code>module.tfs</code></li> </ul>"},{"location":"guide/modules/#importing-modules","title":"Importing modules","text":"<pre><code>// example\nlet mathmod = loadmodule(\"./math_module\")!;\nprint(mathmod.add(1, 2)); // 3\n</code></pre> <p>NOTE: <code>loadmodule</code> must allways be called with <code>!</code> as it requires the <code>self</code> variable.</p> <p>Loading <code>.tfs</code> files as modules:</p> <pre><code>let module = loadmodule(\"./module.tfs\")!;\nmodule.do_whatever();\n</code></pre> <p>In the <code>loadmodule</code> function, after the path to the module you can include <code>loadargs</code></p> <pre><code>let mod = loadmodule(\"./module\", \"everything after the module path will be a loadarg!\", 1, 2, 3)!;\n</code></pre>"},{"location":"guide/modules/#creating-modules","title":"Creating modules","text":"<p>Example module structure:</p> <pre><code>test_module /\n    module.tfs\n</code></pre> <p>When <code>loadmodule</code> is ran on the module folder, <code>module.tfs</code> is ran and returned automatically.</p> <p>Example module code:</p> <pre><code>let fn add(a, b) {\n    a + b;\n}\n\nlet fn sub(a, b) {\n    a - b;\n}\n\nlet test_module = {\n    add: add,\n    sub: sub\n};\n\ntest_module; // modules must always return something!\n</code></pre> <p>You can either save this as a <code>.tfs</code> file and load it appropriately to a <code>.tfs</code> file, or you could make a new folder, create a file called <code>module.tfs</code> and insert the code into the file.</p> <p>You can download and upload modules in <code>PMS</code>.</p>"},{"location":"guide/types/","title":"Data Types","text":"<p>TuffSeal is dynamically typed.</p>"},{"location":"guide/types/#primitive-types","title":"Primitive Types","text":"<pre><code>let n = 42; // integer / number\nlet s = \"hi!\";  // string\n</code></pre>"},{"location":"guide/types/#arrays","title":"Arrays","text":"<pre><code>let arr = [1, 2, 3, \"four\"];\nprint(arr[0]);\n</code></pre> <p>NOTE: Array indexing starts at 0. <code>arr[0]</code> would return \"1\" because the object with the index <code>0</code> inside the array is the number one.</p>"},{"location":"guide/types/#dictionaries","title":"Dictionaries","text":"<pre><code>let dict = {\n    a: \"Hello!\",\n    b: 5\n}\n\nprint(dict.a);\nprint(dict[\"b\"]);\n</code></pre>"},{"location":"guide/types/#type-builtin","title":"<code>type()</code> Builtin","text":"<p>TuffSeal provides a builtin function for detecting what type is a specific variable.</p> <pre><code>let arr = [1, 2, 3]; // array\nprint(type(arr)); // \"array\"\n\n//--------------------------//\nlet dict = {\n    a: 5,\n    b: 10\n}\n\nprint(type(dict)); // \"dictionary\"\n</code></pre>"},{"location":"guide/types/#possible-values","title":"Possible Values","text":"<ul> <li>\"fn\"              (functions)</li> <li>\"int\"             (numbers / integers)</li> <li>\"str\"             (strings)</li> <li>\"bool\"            (booleans)</li> <li>\"array\"           (arrays)</li> <li>\"dictionary\"      (dictionaries)</li> <li>\"luau_external\"   (other)</li> </ul> <p>NOTE: If a variable has a type that doesn't exist inside of TuffSeal, but exists in Luau, it will return <code>luau_external</code></p>"},{"location":"guide/variables/","title":"Variables","text":"<p>There are 2 types of variables in TuffSeal.     - let     - const</p> <p>Variables are declared using <code>let</code> or <code>const</code>.</p> <p>For example:</p> <pre><code>let x = 5;\nconst y = 10;\n</code></pre>"},{"location":"guide/variables/#let","title":"<code>let</code>","text":"<ul> <li>Mutable</li> <li>Can be reassigned</li> </ul> <pre><code>let x = 1;\nx = 2;\n</code></pre>"},{"location":"guide/variables/#const","title":"<code>const</code>","text":"<ul> <li>Immutable</li> <li>Cannot be reassigned</li> <li>Constant arrays and dictionaries are deeply immutable</li> </ul> <p>WARNING: Reassigning a <code>const</code> variable is a runtime error.</p>"},{"location":"pms/commands/","title":"PMS Commands","text":""},{"location":"pms/commands/#main-commands","title":"Main Commands","text":"<pre><code>pms init [project-name]\npms install [module-name] [project-name]\npms remove [module-name] [project-name]\npms upload [module-name] [version] [zip-file]\npms list [module-name]\n</code></pre>"},{"location":"pms/commands/#account-commands","title":"Account Commands","text":"<pre><code>pms register [username] [password]\npms login [username] [password]\npms logout\npms whoami\n</code></pre> <p>NOTE: You do not need a PMS account to use the <code>install</code>, <code>list</code>, or <code>remove</code> options. A PMS account is only require for the <code>upload</code> option.</p>"},{"location":"pms/creating-projects/","title":"Creating Projects","text":"<p>To create a new PMS project, use the commands:</p> <pre><code>pms init my-project\ncd my-project\n</code></pre> <p>Replace <code>my-project</code> with the project name you want to create.</p> <p>Inside <code>my-project</code> there will be <code>main.tfs</code> and a folder called <code>Modules</code> as well as <code>pms_project.json</code>.</p> <p><code>main.tfs</code> should contain the main code for your project.</p> <p>The <code>Modules</code> folder will contain every module you install from PMS.</p> <p>When you run:</p> <pre><code>pms install [module-name]\n</code></pre> <p>The downloaded module will be saved to <code>Modules</code>.</p>"},{"location":"pms/install-upload/","title":"Installing Modules","text":"<p>To install a PMS package, run the command:</p> <pre><code>pms install [package-name] [project-name]\n</code></pre> <p>This will automatically install the latest version of the specified package into your project.</p> <p>If <code>project-name</code> is not provided, PMS will assume that the current folder is the target project to install the package to.</p> <p>To list all available versions for a specified package, run the command:</p> <pre><code>pms list [package-name]\n</code></pre> <p>You can install a specific version of a package by running:</p> <pre><code>pms install package-name@version [project-name]\n</code></pre> <p>Once you've installed a package, you can use it in your <code>main.tfs</code> script by doing:</p> <pre><code>let module = loadmodule(\"./Modules/package-name\")!;\n\nmodule.do_whatever();\n</code></pre>"},{"location":"pms/install-upload/#uploading-modules","title":"Uploading Modules","text":"<p>NOTE: To upload PMS packages, must be logged into a PMS account!</p> <p>Once you have written the code for your module, you can upload it to PMS. To do that, you first have to compress your project into a <code>.zip</code> archive.</p> <p>NOTE: Make sure that <code>main.tfs</code> and other files are directly in the root of the <code>.zip</code> archive! The structure of the archive should look like:</p> <pre><code>module.zip /\n    Modules /\n        ...\n    main.tfs\n</code></pre> <p>Once everything is properly packed, you can upload it to PMS.</p> <p>To upload a package to PMS, run:</p> <pre><code>pms upload [package-name] [version] module.zip\n</code></pre> <p>Your package will be uploaded to PMS servers.</p>"},{"location":"pms/install-upload/#removing-modules","title":"Removing Modules","text":"<p>To remove a package from your project, run the command:</p> <pre><code>pms remove [package-name] [project]\n</code></pre> <p>If the <code>project</code> arg is not provided, PMS will assume the current directory is the target project to remove the package from.</p>"},{"location":"pms/managing-account/","title":"Creating a new account","text":"<p>To create a new PMS account, run the command:</p> <pre><code>pms register [username] [password]\n</code></pre> <p>If the account was created successfully, you can now log into your PMS account.</p>"},{"location":"pms/managing-account/#logging-into-an-account","title":"Logging into an account","text":"<p>To log into a PMS account, run the command:</p> <pre><code>pms login [username] [password]\n</code></pre> <p>If the username and password was correct, you will successfully log into your PMS account. Your auth information will be saved on your device.</p>"},{"location":"pms/managing-account/#logging-out-of-a-pms-account","title":"Logging out of a PMS account","text":"<p>To log out of a PMS account, run the command:</p> <pre><code>pms logout\n</code></pre> <p>This will log you out of your pms account and delete the auth file saved on your device.</p>"},{"location":"pms/managing-account/#identifying-current-pms-account","title":"Identifying current PMS account","text":"<p>To get the username of the current logged-in PMS account, run the command:</p> <pre><code>pms whoami\n</code></pre> <p>This will output your PMS account username.</p>"},{"location":"pms/overview/","title":"PackMySeal (PMS)","text":"<p>PMS is the official package manager for TuffSeal.</p> <p>Modules are distrubuted as folders containing <code>module.tfs</code>.</p>"},{"location":"reference/builtins/","title":"Built-in Functions","text":""},{"location":"reference/builtins/#print","title":"print","text":"<p>Usage:</p> <pre><code>print(...); -- ... :: str | any\n</code></pre> <pre><code>print(\"hello, world!\");\nprint(\"hello, \", \"world!\");\n</code></pre>"},{"location":"reference/builtins/#warn","title":"warn","text":"<p>Usage:</p> <pre><code>warn(...); -- ... :: str | any\n</code></pre> <pre><code>warn(\"this is a warning!\");\n</code></pre>"},{"location":"reference/builtins/#error","title":"error","text":"<p>Usage:</p> <pre><code>error(msg: str, level: int)\n</code></pre> <pre><code>error(\"error!\");\nerror(\"error\", 2);\n</code></pre>"},{"location":"reference/builtins/#len","title":"len","text":"<p>Usage:</p> <pre><code>len(obj: array | str)\n</code></pre> <pre><code>print(len(\"abc\")) // 3\nprint(len([1, 2, 3])) // 3\n</code></pre>"},{"location":"reference/builtins/#ipairs","title":"ipairs","text":"<p>Usage:</p> <pre><code>ipairs(obj: array): dictionary(int, str)\n</code></pre> <pre><code>let arr = [1, 2, 3];\nlet __iter = ipairs(arr);\n\nfor (k, v in __iter) {\n    print(k, v);\n}\n</code></pre>"},{"location":"reference/builtins/#push","title":"push","text":"<p>Usage:</p> <pre><code>push(array: array, value: any)\n</code></pre> <pre><code>let arr = [6, 7, 4, 1];\n\npush(arr, 3);\n\nprint(arr); // [6, 7, 4, 1, 3]\n</code></pre>"},{"location":"reference/builtins/#pop","title":"pop","text":"<p>Usage:</p> <pre><code>pop(array: array)\n</code></pre> <pre><code>let arr = [1, 2, 3];\npop(arr);\nprint(arr); // [1, 2]\n</code></pre>"},{"location":"reference/builtins/#get","title":"get","text":"<p>Usage:</p> <pre><code>get(array: array, index: int)\n</code></pre> <pre><code>let arr = [1, 2, 3];\n\nprint(get(arr, 0)); // 1\n</code></pre>"},{"location":"reference/builtins/#remove","title":"remove","text":"<p>Usage:</p> <pre><code>remove(array: array, index: int)\n</code></pre> <pre><code>let arr = [1, 2, 3];\n\nremove(arr, 0);\nprint(arr); // [2, 3];\n</code></pre>"},{"location":"reference/builtins/#find","title":"find","text":"<p>Usage:</p> <pre><code>find(array: array, value: any): int?\n</code></pre> <pre><code>let arr = [1, 2, 3];\n\nlet idx = find(arr, 3);\nprint(arr);\n</code></pre>"},{"location":"reference/builtins/#format","title":"format","text":"<p>Usage:</p> <pre><code>format(base_string: str, ... :: str): str\n</code></pre> <pre><code>let username = \"Jasper\";\nlet welcome_message = format(\"Welcome, %s\", username);\n\nprint(welcome_message); // Welcome, Jasper\n</code></pre>"},{"location":"reference/builtins/#printf","title":"printf","text":"<p>Usage:</p> <pre><code>printf(base_string: str, ... :: str)\n</code></pre> <pre><code>let username = \"Jasper\";\nprintf(\"Welcome, %s\", username); // Welcome, Jasper\n</code></pre>"},{"location":"reference/builtins/#str","title":"str","text":"<p>Usage:</p> <pre><code>str(obj: any): str\n</code></pre> <pre><code>let x = 10;\nlet s = str(x);\n\nprint(type(s)); // 'str'\nprint(s);       // 10\n</code></pre>"},{"location":"reference/builtins/#int","title":"int","text":"<p>Usage:</p> <pre><code>int(obj: any): int\n</code></pre> <pre><code>let s = \"10\";\nlet i = int(s);\n\nprint(type(i)); // 'int'\nprint(i);       // 10\n</code></pre>"},{"location":"reference/builtins/#hasattr","title":"hasattr","text":"<p>Usage:</p> <pre><code>hasattr(dict: dictionary, key: str): bool\n</code></pre> <pre><code>let a = {\n    b: 5\n}\n\nprint(hasattr(a, \"b\")); // true\n</code></pre>"},{"location":"reference/builtins/#getattr","title":"getattr","text":"<p>Usage:</p> <pre><code>getattr(dict: dictionary, key: str): any\n</code></pre> <pre><code>let a = {\n    b: 5\n}\n\nprint(getattr(a, \"b\")); // 5\n</code></pre>"},{"location":"reference/builtins/#setattr","title":"setattr","text":"<p>Usage:</p> <pre><code>setattr(dict: dictionary, key: str, value: any)\n</code></pre> <pre><code>let a = {\n    x: 5\n};\n\nsetattr(a, \"y\", 10);\nprint(a.y); // 10\n</code></pre>"},{"location":"reference/builtins/#loadmodule","title":"loadmodule","text":"<p>Usage:</p> <pre><code>loadmodule(self, modulePath: str, ... :: any)\n</code></pre> <pre><code>let task = loadmodule(\"@stdlib/task\")!\n\ntask.wait(5);\n\n//-------------------------------------//\n\nlet m = loadmodule(\"./Module\")!\nm.a();\n\n//-------------------------------------//\n\nlet m = loadmodule(\"a.tfs\");\nm.a();\n</code></pre>"},{"location":"reference/builtins/#cloneobject","title":"cloneobject","text":"<p>Usage:</p> <pre><code>cloneobject(obj: any): any\n</code></pre> <pre><code>let s = \"hi!\";\nlet clone = cloneobject(s);\nprint(clone); // hi!\n</code></pre>"},{"location":"reference/builtins/#type","title":"type","text":"<p>Usage:</p> <pre><code>type(obj: any): \"fn\" | \"int\" | \"str\" | \"array\" | \"dictionary\" | \"bool\"\n</code></pre> <pre><code>let s = \"hi\";\nprint(type(s)); // str\n</code></pre>"},{"location":"reference/keywords/","title":"Keywords","text":"<p><code>let</code>, <code>const</code>, <code>fn</code>, <code>elseif</code>, <code>else</code>, <code>for</code>, <code>while</code>, <code>in</code>, <code>true</code>, <code>false</code>, <code>null</code></p>"},{"location":"reference/stdlib/","title":"TuffSeal stdlib Reference","text":""},{"location":"reference/stdlib/#task","title":"task","text":""},{"location":"reference/stdlib/#wait","title":"wait","text":"<p>Yields the current thread for a specified amount of time.</p> <p>Usage:</p> <pre><code>task.wait(time: int); // time should be in seconds.\n</code></pre> <pre><code>let task = loadmodule(\"@stdlib/task\")!;\n\nprint(\"Waiting 5 seconds...\");\ntask.wait(5);\nprint(\"Done!\");\n</code></pre>"},{"location":"reference/stdlib/#delay","title":"delay","text":"<p>Runs a function after a specified amount of time</p> <p>Usage:</p> <pre><code>task.delay(seconds: int, f: fn)\n</code></pre> <pre><code>let task = loadmodule(\"@stdlib/task\")!;\n\nfn to_delay()\n{\n    print(\"this task was delayed!\");\n}\n\ntask.delay(2, to_delay());\n\n</code></pre>"},{"location":"reference/stdlib/#spawn","title":"spawn","text":"<p>Creates a new task that runs concurrently.</p> <p>Usage:</p> <pre><code>task.spawn(f: fn)\n</code></pre> <pre><code>let task = loadmodule(\"@stdlib/task\")!;\n\nfn task_func()\n{\n    while (true) {\n        task.wait(1);\n        print(\"hi!\");\n    }\n}\n\nlet new_task = task.spawn(task_func);\n</code></pre>"},{"location":"reference/stdlib/#defer","title":"defer","text":"<p>Defers a thread or function to run at the end of the current task queue.</p> <p>Usage:</p> <pre><code>task.defer(f: fn)\n</code></pre> <pre><code>let task = loadmodule(\"@stdlib/task\")!;\n\nfn task1() { print(\"OK\") };\nfn task2() { print(\"OK\") };\n\nfn __d()\n{\n    print(\"this task runs last.\");\n}\n\nlet task_1 = task.spawn(task1);\nlet task_2 = task.spawn(task2);\nlet deferred_thread = task.defer(__d);\n\n</code></pre>"},{"location":"reference/stdlib/#cancel","title":"cancel","text":"<p>Stops a currently scheduled thread from resuming.</p> <p>Usage:</p> <pre><code>task.cancel(thread)\n</code></pre> <pre><code>let task = loadmodule(\"@stdlib/task\")!;\n\nfn task_fn()\n{\n    while (true) {\n        task.wait(1);\n        print(\"hello!\");\n    }\n}\n\nlet t = task.spawn(task_fn);\ntask.wait(5);\ntask.cancel(t); // terminate the task after 5 seconds\n</code></pre>"},{"location":"reference/stdlib/#stdio","title":"stdio","text":""},{"location":"reference/stdlib/#prompt","title":"prompt","text":"<p>Prompts for user input using the wanted kind of prompt:</p> <ul> <li><code>text</code> - Prompts for a plain text string from the user.</li> <li><code>confirm</code> - Prompts the user to confirm with y / n (yes / no)</li> <li><code>select</code> - Prompts the user to select one or more values from a list</li> <li><code>null</code> - Equivalent to \"text\" with no extra arguments</li> </ul> <p>Usage:</p> <pre><code>stdio.prompt(kind: str, message: str): str\n</code></pre> <pre><code>let stdio = loadmodule(\"@std/stdio\")!;\n\nlet text = stdio.prompt(\"text\", \"Write some text: \");\n\nprint(text);\n</code></pre>"},{"location":"reference/stdlib/#color","title":"color","text":"<p>Returns an ANSI string that can be used to modify the persistent output color.</p> <p>Pass <code>\"reset\"</code> to get a string that resets the persistent output color.</p> <p>Usage:</p> <pre><code>stdio.color(color: str): str\n</code></pre> <pre><code>let stdio = loadmodule(\"@std/stdio\")!;\n\nprint(stdio.color(\"red\"));\nprint(\"This text is red!\");\nprint(stdio.color(\"reset\"));\nprint(\"This text is back to normal.\");\n</code></pre>"},{"location":"reference/stdlib/#style","title":"style","text":"<p>Return an ANSI string that can be used to modify the persistent output style.</p> <p>Pass <code>\"reset\"</code> to get a string that can reset the persistent output style.</p> <p>Usage:</p> <pre><code>stdio.style(style: str): str\n</code></pre> <pre><code>let stdio = loadmodule(\"@std/stdio\")!;\n\nprint(stdio.style(\"bold\"));\nprint(\"This text will be bold!\");\nprint(stdio.style(\"reset\"));\n</code></pre>"},{"location":"reference/stdlib/#write","title":"write","text":"<p>Writes a string directly to stdout, without any new line.</p> <p>Usage:</p> <pre><code>stdio.write(s: str)\n</code></pre> <pre><code>let stdio = loadmodule(\"@std/stdio\")!;\n\nstdio.write(\"Hello, \");\nstdio.write(\"world!\\n\");\n\n// both of these will output on the same line.\n</code></pre>"},{"location":"reference/stdlib/#ewrite","title":"ewrite","text":"<p>Writes a string directly to stderr, without any new line.</p> <p>Usage:</p> <pre><code>stdio.ewrite(s: str)\n</code></pre> <pre><code>let stdio = loadmodule(\"@std/stdio\")!;\n\nstdio.ewrite(\"Error: \");\nstdio.ewrite(\"whatever\\n\");\n\n// Both of these will output on the same line.\n</code></pre>"},{"location":"reference/stdlib/#readline","title":"readLine","text":"<p>Reads a single line from stdin.</p> <p>Usage:</p> <pre><code>stdio.readLine(): str\n</code></pre> <pre><code>let stdio = loadmodule(\"@std/stdio\")!;\n\nprint(stdio.readLine());\n</code></pre>"},{"location":"reference/stdlib/#readtoend","title":"readToEnd","text":"<p>Reads the entire input from stdin.</p> <p>Usage:</p> <pre><code>stdio.readToEnv(): str\n</code></pre> <pre><code>let stdio = loadmodule(\"@std/stdio\")!;\n\nprint(stdio.readToEnd());\n</code></pre> <p>Here is a clean, consistent Markdown documentation section for the <code>fs</code> module in TuffSeal, based on the functions and types you provided:</p>"},{"location":"reference/stdlib/#fs","title":"fs","text":"<p>File system operations module. Provides synchronous file and directory manipulation.  </p> <p>All functions throw an error on failure (file/directory not found, permission denied, I/O error, invalid operation, etc.).</p>"},{"location":"reference/stdlib/#readfile","title":"readFile","text":"<p>Reads the entire contents of a file as a string.</p> <pre><code>fs.readFile(path: str): str\n</code></pre> <p>Throws if: - path does not point to an existing file - no read permission - I/O error occurred</p>"},{"location":"reference/stdlib/#readdir","title":"readDir","text":"<p>Returns a list of file and directory names (base names only) in the specified directory.</p> <pre><code>fs.readDir(path: str): [str]\n</code></pre> <p>Throws if: - path is not an existing directory - no read permission - I/O error occurred</p> <p>Example:</p> <pre><code>let entries = fs.readDir(\"scripts\");\nfor (name in entries) {\n    print(name);\n}\n</code></pre>"},{"location":"reference/stdlib/#writefile","title":"writeFile","text":"<p>Writes (or overwrites) a file with the given content.</p> <pre><code>fs.writeFile(path: str, contents: str)\n</code></pre> <p>Throws if: - parent directory does not exist - no write permission - I/O error occurred</p>"},{"location":"reference/stdlib/#writedir","title":"writeDir","text":"<p>Creates a directory and all necessary parent directories (like <code>mkdir -p</code>).</p> <pre><code>fs.writeDir(path: str)\n</code></pre> <p>Throws if: - path already exists as a file or directory - no permission to create directory/parents - I/O error occurred</p>"},{"location":"reference/stdlib/#removefile","title":"removeFile","text":"<p>Deletes a file (does not work on directories).</p> <pre><code>fs.removeFile(path: str)\n</code></pre> <p>Throws if: - path is not an existing file - no permission to remove - I/O error occurred</p>"},{"location":"reference/stdlib/#removedir","title":"removeDir","text":"<p>Removes a directory and all of its contents recursively.</p> <pre><code>fs.removeDir(path: str)\n</code></pre> <p>Throws if: - path is not an existing directory - no permission to remove - I/O error occurred</p> <p>Warning: This operation is destructive \u2014 use with caution!</p>"},{"location":"reference/stdlib/#metadata","title":"metadata","text":"<p>Returns detailed metadata about a file or directory.</p> <pre><code>fs.metadata(path: str): Metadata\n</code></pre> <p>Throws if: - no permission to read metadata - I/O error occurred</p> <p>Returns: A dictionary with the following keys: - <code>kind</code>: <code>\"file\"</code>, <code>\"dir\"</code>, or <code>\"symlink\"</code> - <code>exists</code>: <code>bool</code> - <code>createdAt</code>: <code>DateTime</code> (creation time) - <code>modifiedAt</code>: <code>DateTime</code> (last modification time) - <code>accessedAt</code>: <code>DateTime</code> (last access time) - <code>permissions</code>: <code>MetadataPermissions</code> dictionary</p> <p>Note: Timestamps are Unix epoch based and depend on system clock accuracy.</p>"},{"location":"reference/stdlib/#isfile","title":"isFile","text":"<p>Checks whether the path points to a regular file.</p> <pre><code>fs.isFile(path: str): bool\n</code></pre> <p>Throws if: - no permission to read metadata - I/O error occurred</p>"},{"location":"reference/stdlib/#isdir","title":"isDir","text":"<p>Checks whether the path points to a directory.</p> <pre><code>fs.isDir(path: str): bool\n</code></pre> <p>Throws if: - no permission to read metadata - I/O error occurred</p>"},{"location":"reference/stdlib/#move","title":"move","text":"<p>Moves (renames) a file or directory to a new location.</p> <pre><code>fs.move(from: str, to: str, overwriteOrOptions: bool | WriteOptions = false)\n</code></pre> <p>Throws if: - no read permission at source or write permission at destination - target already exists (unless <code>overwrite</code> is <code>true</code>) - source and destination are on different mount points - I/O error occurred</p>"},{"location":"reference/stdlib/#copy","title":"copy","text":"<p>Recursively copies a file or directory to a new location.</p> <pre><code>fs.copy(from: str, to: str, overwriteOrOptions: bool | WriteOptions = false)\n</code></pre> <p>Throws if: - no read permission at source or write permission at destination - target already exists (unless <code>overwrite</code> is <code>true</code>) - I/O error occurred</p>"},{"location":"reference/stdlib/#types","title":"Types","text":""},{"location":"reference/stdlib/#metadatapermissions","title":"MetadataPermissions","text":"<pre><code>{\n    readOnly: bool\n}\n</code></pre>"},{"location":"reference/stdlib/#metadata_1","title":"Metadata","text":"<pre><code>{\n    kind: str,          // \"file\" | \"dir\" | \"symlink\"\n    exists: bool,\n    createdAt: DateTime,\n    modifiedAt: DateTime,\n    accessedAt: DateTime,\n    permissions: MetadataPermissions\n}\n</code></pre>"},{"location":"reference/stdlib/#writeoptions","title":"WriteOptions","text":"<p>Options for write/move/copy operations:</p> <pre><code>{\n    overwrite: bool     // whether to overwrite existing target (default: false)\n    // more keys may be added in future versions\n}\n</code></pre> <p>Loading the module:</p> <pre><code>let fs = loadmodule(\"@std/fs\")!;\n</code></pre>"},{"location":"reference/stdlib/#process","title":"process","text":"<p>Process management module. Provides access to current process information, environment, command-line arguments, and the ability to spawn and interact with child processes (synchronously or asynchronously).</p>"},{"location":"reference/stdlib/#properties","title":"Properties","text":"<p>os The current operating system identifier. Possible values: <code>\"linux\"</code>, <code>\"macos\"</code>, <code>\"windows\"</code></p> <p>arch The processor architecture. Possible values: <code>\"x86_64\"</code>, <code>\"aarch64\"</code></p> <p>endianness The processor endianness. Possible values: <code>\"little\"</code>, <code>\"big\"</code></p> <p>args Array of command-line arguments passed when the script was executed (<code>[str]</code>).</p> <p>cwd The current working directory of the running process (<code>str</code>).</p> <p>env Table of current environment variables (<code>{ [str]: str? }</code>). Reading returns the current env vars. Writing to this table updates the process environment variables.</p>"},{"location":"reference/stdlib/#exit","title":"exit","text":"<p>Immediately terminates the script with the given exit code. <code>0</code> indicates success; any other value indicates an error.</p> <pre><code>process.exit(code: int)\n</code></pre> <p>Returns: never</p>"},{"location":"reference/stdlib/#create","title":"create","text":"<p>Spawns a child process in the background and returns immediately. Useful when you need to interact with stdin/stdout/stderr while the process runs.</p> <pre><code>process.create(\n    program: str,\n    params: [str]? = nil,\n    options: CreateOptions? = nil\n): ChildProcess\n</code></pre> <p>Returns a <code>ChildProcess</code> dictionary containing: - <code>stdin</code> \u2192 <code>ChildProcessWriter</code> - <code>stdout</code> \u2192 <code>ChildProcessReader</code> - <code>stderr</code> \u2192 <code>ChildProcessReader</code> - <code>kill()</code> \u2192 method to forcefully terminate the process - <code>status()</code> \u2192 yields until process exits and returns exit code/status</p>"},{"location":"reference/stdlib/#exec","title":"exec","text":"<p>Runs a child process synchronously and waits for it to complete. Returns the final status and captured output.</p> <pre><code>process.exec(\n    program: str,\n    params: [str]? = nil,\n    options: ExecOptions? = nil\n): ExecResult\n</code></pre> <p>Returns an <code>ExecResult</code> dictionary containing: - <code>ok</code>: <code>bool</code> (true if exit code was 0) - <code>code</code>: <code>int</code> (exit code, 0 if none was set) - <code>stdout</code>: <code>str</code> (captured standard output) - <code>stderr</code>: <code>str</code> (captured standard error)</p>"},{"location":"reference/stdlib/#types_1","title":"Types","text":""},{"location":"reference/stdlib/#execstdiokind","title":"ExecStdioKind","text":"<p>Controls how stdio streams are handled during <code>process.exec</code>. Possible values: - <code>\"default\"</code> - capture into result table only - <code>\"inherit\"</code> - inherit from parent (write to both result and parent's stream) - <code>\"forward\"</code> - forward to parent's stream only (no capture) - <code>\"none\"</code> - no stream created</p>"},{"location":"reference/stdlib/#execstdiooptions","title":"ExecStdioOptions","text":"<pre><code>{\n    stdin?: str | buffer,               // input data to send to child stdin\n    stdout?: ExecStdioKind,             // how to handle stdout\n    stderr?: ExecStdioKind              // how to handle stderr\n}\n</code></pre>"},{"location":"reference/stdlib/#execoptions","title":"ExecOptions","text":"<pre><code>{\n    cwd?: str,                          // working directory for the child\n    env?: { [str]: str? },              // additional/modified environment variables\n    shell?: bool | str,                 // run in shell (true = default shell, str = specific shell)\n    stdio?: ExecStdioOptions | ExecStdioKind\n}\n</code></pre>"},{"location":"reference/stdlib/#createoptions","title":"CreateOptions","text":"<pre><code>{\n    cwd?: str,\n    env?: { [str]: str? },\n    shell?: bool | str\n}\n</code></pre>"},{"location":"reference/stdlib/#childprocess","title":"ChildProcess","text":"<p>Returned by <code>process.create</code>.  </p> <pre><code>{\n    stdin: ChildProcessWriter,\n    stdout: ChildProcessReader,\n    stderr: ChildProcessReader,\n    kill: fn(),                         // kill the child process\n    status: fn(): int                   // yields until exit, returns exit code\n}\n</code></pre>"},{"location":"reference/stdlib/#execresult","title":"ExecResult","text":"<p>Returned by <code>process.exec</code>.  </p> <pre><code>{\n    ok: bool,\n    code: int,\n    stdout: str,\n    stderr: str\n}\n</code></pre>"},{"location":"reference/stdlib/#childprocessreader","title":"ChildProcessReader","text":"<p>Reader for child process output streams (<code>stdout</code>/<code>stderr</code>).</p> <p>Methods:</p> <p><code>read(chunkSize: int? = 1024): str?</code> Reads up to <code>chunkSize</code> bytes. Returns <code>nil</code> when no more data is available. May yield if waiting for new data.</p> <p><code>readToEnd(): str</code> Reads all remaining data until the process exits (yields).</p>"},{"location":"reference/stdlib/#childprocesswriter","title":"ChildProcessWriter","text":"<p>Writer for child process input stream (<code>stdin</code>).</p> <p>Methods:</p> <p><code>write(data: str | buffer)</code> Writes data to the child\u2019s stdin.</p> <p><code>close()</code> Closes the stdin stream (signals end-of-input to the child).</p> <p>Loading the module:</p> <pre><code>let process = loadmodule(\"@std/process\")!;\n</code></pre> <p>Most operations are synchronous where possible. Child process handling is blocking only when using <code>exec</code> or when explicitly waiting via <code>status()</code> / <code>readToEnd()</code>. Future versions may add more advanced process control features (signals, priority, etc.).</p>"},{"location":"reference/stdlib/#serde","title":"serde","text":"<p>Serialization, deserialization, compression, decompression, and hashing utilities. The <code>serde</code> module provides a clean, high-level interface for common data encoding/decoding and integrity operations.</p>"},{"location":"reference/stdlib/#functions","title":"Functions","text":"<p>encode</p> <p>Encodes a value into a string using the specified format.</p> <pre><code>serde.encode(\n    format: EncodeDecodeFormat,\n    value: any,\n    pretty: bool = false\n): str\n</code></pre> <ul> <li><code>pretty</code> is only supported for <code>\"json\"</code> and <code>\"toml\"</code> formats</li> </ul> <p>decode</p> <p>Decodes a string into a TuffSeal value using the specified format.</p> <pre><code>serde.decode(\n    format: EncodeDecodeFormat,\n    encoded: str\n): any\n</code></pre> <p>compress</p> <p>Compresses a string using the given compression format.</p> <pre><code>serde.compress(\n    format: CompressDecompressFormat,\n    s: str,\n    level: int? = nil\n): str\n</code></pre> <ul> <li>If <code>level</code> is omitted, the best (usually highest) compression level is used</li> <li>Level is automatically clamped to the format\u2019s valid range</li> </ul> <p>decompress</p> <p>Decompresses a previously compressed string.</p> <pre><code>serde.decompress(\n    format: CompressDecompressFormat,\n    s: str\n): str\n</code></pre> <p>hash</p> <p>Computes a cryptographic hash of the message and returns it as a lowercase hex string.</p> <pre><code>serde.hash(\n    algorithm: HashAlgorithm,\n    message: str\n): str\n</code></pre> <p>hmac</p> <p>Computes HMAC (keyed-hash message authentication code) using the given algorithm, message, and secret. Returns the result as a base64-encoded string.</p> <pre><code>serde.hmac(\n    algorithm: HashAlgorithm,\n    message: str,\n    secret: str | buffer\n): str\n</code></pre>"},{"location":"reference/stdlib/#supported-formats-algorithms","title":"Supported Formats &amp; Algorithms","text":""},{"location":"reference/stdlib/#encodedecodeformat","title":"EncodeDecodeFormat","text":"<p>Supported serialization/deserialization formats:</p> <ul> <li><code>\"json\"</code> \u2013 https://www.json.org</li> <li><code>\"yaml\"</code> \u2013 https://yaml.org</li> <li><code>\"toml\"</code> \u2013 https://toml.io</li> </ul>"},{"location":"reference/stdlib/#compressdecompressformat","title":"CompressDecompressFormat","text":"<p>Supported compression/decompression algorithms:</p> <ul> <li><code>\"brotli\"</code> \u2013 https://github.com/google/brotli</li> <li><code>\"gzip\"</code> \u2013 https://www.gnu.org/software/gzip</li> <li><code>\"lz4\"</code> \u2013 https://github.com/lz4/lz4</li> <li><code>\"zlib\"</code> \u2013 https://www.zlib.net</li> <li><code>\"zstd\"</code> \u2013 https://github.com/facebook/zstd</li> </ul>"},{"location":"reference/stdlib/#hashalgorithm","title":"HashAlgorithm","text":"<p>Supported hash algorithms:</p> <ul> <li><code>\"md5\"</code> \u2013 https://en.wikipedia.org/wiki/MD5</li> <li><code>\"sha1\"</code> \u2013 https://en.wikipedia.org/wiki/SHA-1</li> <li><code>\"sha224\"</code></li> <li><code>\"sha256\"</code></li> <li><code>\"sha384\"</code></li> <li><code>\"sha512\"</code> \u2013 (all part of SHA-2 family)</li> <li><code>\"sha3-224\"</code></li> <li><code>\"sha3-256\"</code></li> <li><code>\"sha3-384\"</code></li> <li><code>\"sha3-512\"</code> \u2013 (SHA-3 family)</li> <li><code>\"blake3\"</code> \u2013 https://en.wikipedia.org/wiki/BLAKE3</li> </ul> <p>Loading the module:</p> <pre><code>let serde = loadmodule(\"@std/serde\")!;\n</code></pre> <p>Quick examples:</p> <pre><code>// JSON pretty-print\nlet data = { name: \"TuffSeal\", version: 1.0 };\nprint(serde.encode(\"json\", data, true));\n\n// Compress &amp; decompress\nlet original = \"very very long text...\";\nlet compressed = serde.compress(\"zstd\", original);\nlet restored = serde.decompress(\"zstd\", compressed);\n\n// Hashing\nprint(serde.hash(\"sha256\", \"hello world\")); // hex string\n\n// HMAC example\nlet signature = serde.hmac(\"sha256\", \"message\", \"my-secret-key\");\n</code></pre> <p>All functions throw errors on invalid formats, malformed input, or unsupported operations.  </p>"},{"location":"reference/stdlib/#net","title":"net","text":"<p>Built-in library for network access. Provides high-level HTTP client/server functionality, WebSocket support, URL encoding/decoding, and low-level TCP socket operations.</p>"},{"location":"reference/stdlib/#functions_1","title":"Functions","text":"<p>request</p> <p>Sends an HTTP request and returns the response.</p> <pre><code>net.request(config: str | FetchParams): FetchResponse\n</code></pre> <ul> <li>Accepts a simple URL string or a full <code>FetchParams</code> dictionary</li> <li>Does not throw on HTTP error status codes (4xx/5xx) \u2014 check <code>response.ok</code> instead</li> <li>Throws only on network/connection failures</li> </ul> <p>socket</p> <p>Connects to a WebSocket server at the given URL.</p> <pre><code>net.socket(url: str): WebSocket\n</code></pre> <p>Throws if: - The server does not support WebSockets - Connection/handshake fails</p> <p>serve</p> <p>Starts an HTTP server listening on the given port.</p> <pre><code>net.serve(port: int, handlerOrConfig: fn | ServeConfig): ServeHandle\n</code></pre> <ul> <li>Non-blocking \u2014 returns immediately</li> <li>Server runs until <code>handle.stop()</code> is called</li> <li>Simple usage: pass a handler function</li> <li>Advanced usage: pass a <code>ServeConfig</code> dictionary</li> </ul> <p>urlEncode</p> <p>URL-encodes a string.</p> <pre><code>net.urlEncode(s: str, binary: bool = false): str\n</code></pre> <p>urlDecode</p> <p>URL-decodes a string.</p> <pre><code>net.urlDecode(s: str, binary: bool = false): str\n</code></pre>"},{"location":"reference/stdlib/#tcp-support","title":"TCP Support","text":"<p>net.tcp.connect</p> <p>Connects to a remote host/port and returns a <code>TcpStream</code>.</p> <pre><code>net.tcp.connect(\n    host: str,\n    port: int,\n    config: bool | TcpConfig = false\n): TcpStream\n</code></pre> <ul> <li><code>config</code> can be <code>true</code> for simple TLS, or a full <code>TcpConfig</code> table</li> <li>Throws on connection failure</li> </ul>"},{"location":"reference/stdlib/#types_2","title":"Types","text":"<p>FetchParams</p> <pre><code>{\n    url: str,                           // required\n    method?: str,                       // default: \"GET\"\n    body?: str,\n    query?: { [str]: str },\n    headers?: { [str]: str },\n    options?: FetchParamsOptions\n}\n</code></pre> <p>FetchParamsOptions</p> <pre><code>{\n    decompress?: bool                   // auto-decompress response (default: true)\n}\n</code></pre> <p>FetchResponse</p> <pre><code>{\n    ok: bool,                           // true if 200\u2013299\n    statusCode: int,\n    statusMessage: str,\n    headers: { [str]: str },\n    body: str\n}\n</code></pre> <p>ServeRequest</p> <p>Incoming request in <code>serve</code> handler:</p> <pre><code>{\n    path: str,\n    query: { [str]: str },\n    method: str,                        // uppercase\n    headers: { [str]: str },\n    body: str\n}\n</code></pre> <p>ServeResponse</p> <p>What your handler should return:</p> <pre><code>{\n    status?: int,                       // 100\u2013599, default 200\n    headers?: { [str]: str },\n    body?: str\n}\n</code></pre> <p>ServeConfig</p> <p>Advanced server configuration:</p> <pre><code>{\n    address?: str,                      // e.g. \"http://0.0.0.0\"\n    handleRequest?: fn(request): ServeResponse,\n    handleWebSocket?: fn(ws: WebSocket)\n}\n</code></pre> <p>ServeHandle</p> <pre><code>{\n    stop: fn()                          // gracefully shuts down the server\n}\n</code></pre> <p>WebSocket</p> <pre><code>{\n    // When open:\n    send: fn(data: str | buffer),\n    next: fn(): str?,                   // yields for next message, nil on close\n    close: fn(code?: int),\n\n    // Read-only:\n    closeCode: int?                     // nil until closed, 1000\u20134999 after\n}\n</code></pre> <p>TcpConfig</p> <pre><code>{\n    tls?: bool,                         // enable TLS\n    ttl?: int                           // IP time-to-live\n}\n</code></pre> <p>TcpStream</p> <p>Low-level TCP/TLS stream:</p> <pre><code>{\n    read: fn(): str?,                   // read available data, may return nil\n    write: fn(data: str | buffer),\n    close: fn()\n}\n</code></pre> <p>Loading the module:</p> <pre><code>let net = loadmodule(\"@std/net\")!;\n</code></pre> <p>Quick examples:</p> <pre><code>// Simple GET\nlet resp = net.request(\"https://api.example.com/data\");\nprint(resp.statusCode, resp.body);\n\n// POST JSON\nlet resp = net.request({\n    url: \"https://api.example.com/items\",\n    method: \"POST\",\n    headers: { [\"Content-Type\"]: \"application/json\" },\n    body: serde.encode(\"json\", { name: \"New Item\" })\n});\n\n// Tiny echo server\nnet.serve(8080, fn(req) {\n    {\n        status: 200,\n        body: \"You said: \" + req.body\n    };\n});\n</code></pre>"},{"location":"reference/stdlib/#datetime","title":"datetime","text":"<p>Date and time manipulation module. Provides a modern, precise <code>DateTime</code> type with support for multiple time zones (local/UTC), formatting, parsing, and conversions.</p>"},{"location":"reference/stdlib/#properties-on-datetime-instances","title":"Properties (on DateTime instances)","text":"<p>unixTimestamp <code>number</code> Seconds since UNIX epoch (1970-01-01 00:00:00 UTC), with fractional part for sub-second precision.</p> <p>unixTimestampMillis <code>number</code> Milliseconds since UNIX epoch.</p>"},{"location":"reference/stdlib/#constructors","title":"Constructors","text":"<p>now Returns the current date and time.</p> <pre><code>datetime.now(): DateTime\n</code></pre> <p>fromUnixTimestamp</p> <p>Creates a <code>DateTime</code> from a UNIX timestamp (seconds since epoch). Supports fractional seconds down to nanosecond precision (truncated).</p> <pre><code>datetime.fromUnixTimestamp(unixTimestamp: number): DateTime\n</code></pre> <p>fromUniversalTime Creates a <code>DateTime</code> from UTC date/time components.</p> <pre><code>datetime.fromUniversalTime(values: DateTimeValueArguments): DateTime\n</code></pre> <p>Throws if the date is invalid (e.g. February 30, non-leap February 29).</p> <p>fromLocalTime Creates a <code>DateTime</code> from local date/time components.</p> <pre><code>datetime.fromLocalTime(values: DateTimeValueArguments): DateTime\n</code></pre> <p>Throws on invalid dates (same rules as <code>fromUniversalTime</code>).</p> <p>fromRfc3339 Parses an RFC 3339 / ISO 8601 date-time string (preferred modern format).</p> <pre><code>datetime.fromRfc3339(rfc3339Date: str): DateTime\n</code></pre> <p>Throws on invalid format.</p> <p>fromRfc2822 Parses an RFC 2822 date-time string (common in email/HTTP).</p> <pre><code>datetime.fromRfc2822(rfc2822Date: str): DateTime\n</code></pre> <p>Throws on invalid format.</p> <p>fromIsoDate DEPRECATED \u2014 use <code>fromRfc3339</code> instead.</p>"},{"location":"reference/stdlib/#methods-on-datetime-instances","title":"Methods (on DateTime instances)","text":"<p>formatLocalTime</p> <p>Formats as local time using strftime-style pattern.</p> <pre><code>dt:formatLocalTime(formatString?: str, locale?: Locale): str\n</code></pre> <p>Defaults: <code>\"%Y-%m-%d %H:%M:%S\"</code>, <code>\"en\"</code></p> <p>formatUniversalTime</p> <p>Formats as UTC using strftime-style pattern.</p> <pre><code>dt:formatUniversalTime(formatString?: str, locale?: Locale): str\n</code></pre> <p>toRfc3339</p> <p>Formats as RFC 3339 string (recommended).</p> <pre><code>dt:toRfc3339(): str\n</code></pre> <p>toRfc2822</p> <p>Formats as RFC 2822 string.</p> <pre><code>dt:toRfc2822(): str\n</code></pre> <p>toIsoDate DEPRECATED \u2014 use <code>toRfc3339</code> instead.</p> <p>toLocalTime</p> <p>Returns local date/time components as a table.</p> <pre><code>dt:toLocalTime(): DateTimeValueReturns\n</code></pre> <p>Contains: <code>year</code>, <code>month</code>, <code>day</code>, <code>hour</code>, <code>minute</code>, <code>second</code>, <code>millisecond</code></p> <p>toUniversalTime</p> <p>Returns UTC date/time components as a table.</p> <pre><code>dt:toUniversalTime(): DateTimeValueReturns\n</code></pre>"},{"location":"reference/stdlib/#types_3","title":"Types","text":"<p>Locale Supported formatting locales:</p> <ul> <li><code>\"en\"</code> \u2013 English  </li> <li><code>\"de\"</code> \u2013 German  </li> <li><code>\"es\"</code> \u2013 Spanish  </li> <li><code>\"fr\"</code> \u2013 French  </li> <li><code>\"it\"</code> \u2013 Italian  </li> <li><code>\"ja\"</code> \u2013 Japanese  </li> <li><code>\"pl\"</code> \u2013 Polish  </li> <li><code>\"pt-br\"</code> \u2013 Brazilian Portuguese  </li> <li><code>\"pt\"</code> \u2013 Portuguese  </li> <li><code>\"tr\"</code> \u2013 Turkish  </li> </ul> <p>DateTimeValues / DateTimeValueArguments / DateTimeValueReturns</p> <pre><code>{\n    year: int,        // 1400\u20139999\n    month: int,       // 1\u201312\n    day: int,         // 1\u201331\n    hour: int,        // 0\u201323\n    minute: int,      // 0\u201359\n    second: int,      // 0\u201360 (60 = leap second)\n    millisecond?: int // 0\u2013999 (optional in input, always present in output)\n}\n</code></pre> <p>Loading the module:</p> <pre><code>let datetime = loadmodule(\"@std/datetime\")!;\n</code></pre> <p>Quick examples:</p> <pre><code>let now = datetime.now();\nprint(now:toRfc3339());                    // 2026-01-11T11:30:45.123Z\n\nprint(now:formatLocalTime(\"%A, %d %B %Y\")); // Sunday, 11 January 2026\n\nlet custom = datetime.fromUniversalTime({\n    year = 2025,\n    month = 12,\n    day = 25,\n    hour = 18,\n    minute = 30\n});\n\nprint(custom:toRfc3339());                 // 2025-12-25T18:30:00Z\n</code></pre> <p>The <code>datetime</code> module is built for reliability, modern standards (RFC 3339 preferred), and easy localization. Leap seconds are supported where present in the underlying system. Future versions may add timezone-aware objects and more locales.</p>"}]}